<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lys091112.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="且行且珍惜">
<meta property="og:type" content="website">
<meta property="og:title" content="Crescent">
<meta property="og:url" content="http://lys091112.github.io/index.html">
<meta property="og:site_name" content="Crescent">
<meta property="og:description" content="且行且珍惜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Crescent">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lys091112.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Crescent</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Crescent</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Crescent's Footprint</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Crescent</p>
  <div class="site-description" itemprop="description">且行且珍惜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/06/15/ConcurrentLinkedQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/15/ConcurrentLinkedQueue/" class="post-title-link" itemprop="url">ConcurrentLinkedQueue 源码解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-15 10:55:02" itemprop="dateCreated datePublished" datetime="2020-06-15T10:55:02+00:00">2020-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们常用的线程安全的队列主要有BlockingLinkedQueue 、 ConcurrentLinkedQueue, 它俩的主要区别是一个使用了锁 ，一个基于CAS + volatile 实现的无锁队列，本篇我们主要分析ConcurrentLinedQueue的实现原理。</p>
<h2 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h2><p>队列的节点数据结构，原子性的修改主要使用UNSAFE 来通过内存偏移地址操作元素，详细请搜索 <code>UNSAFE</code> 的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;   </span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;   </span><br><span class="line">  </span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">          UNSAFE.putObject(<span class="built_in">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casItem</span><span class="params">(E cmp, E val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过内存偏移地址修改变量值</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> itemOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Node.class;</span><br><span class="line">                itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-head-tail-的说明"><a href="#2-head-tail-的说明" class="headerlink" title="2. head tail 的说明"></a>2. head tail 的说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不变性:</span></span><br><span class="line"><span class="comment"> *  - 队列中所有未删除的节点都可以通过head节点的succ方法查找到</span></span><br><span class="line"><span class="comment"> *  - head节点一定不可能等于null</span></span><br><span class="line"><span class="comment"> *  - (tmp = head).next != tmp,即head的next不能指向自己。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可变性:</span></span><br><span class="line"><span class="comment"> * - head的item可能为null,也可能不为null</span></span><br><span class="line"><span class="comment"> * - tail节点可能会滞后于head节点，因此从head节点未必一定可以找到tail节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不变性:</span></span><br><span class="line"><span class="comment"> *  - 节点中的最后一个元素总是可以通过tail的succ方法来获取</span></span><br><span class="line"><span class="comment"> *  - tail节点不等于null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可变性:</span></span><br><span class="line"><span class="comment"> *  - head的item可能为null,也可能不为null</span></span><br><span class="line"><span class="comment"> *  - tail 节点的next可能指向自己，也可能不指向自己</span></span><br><span class="line"><span class="comment"> *  - tail节点可能会滞后于head节点，因此从head节点未必一定可以找到tail节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-1-tail-落后于head的情况"><a href="#2-1-tail-落后于head的情况" class="headerlink" title="2.1 tail 落后于head的情况"></a>2.1 tail 落后于head的情况</h3><p>先offer 后 poll， offer之后 head的next节点会指向下一个节点，如果此时poll ，那么 head.item &#x3D;&#x3D; null，所以此时head会移动到head.next,成为新的节点 ，在下一次的遍历中head中的item出队 ，而此时tail仍指向最原始的头节点，从而出现了tail滞后于head的情况</p>
<p><img src="/../images/tail-after-head.png" alt="tail滞后head"></p>
<h2 id="3-Offer-方法"><a href="#3-Offer-方法" class="headerlink" title="3. Offer 方法"></a>3. Offer 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// p is last node</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                    <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                    <span class="comment">// 因为tail的滞后性 ，并不会随时随地的修改tail，只有当tail指针与真实的尾节点</span></span><br><span class="line">                    <span class="comment">// 距离相差超过1时 才会进行更新。 该操作如果失败，说明有其他线程执行成功，所以不需重试</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当执行 poll 或 remove操作时，会有这种情况产生</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// p == q 说明p变成来哨兵节点（即被poll删除了） 因此需要判断t的执行是否与当前的tail节点一致</span></span><br><span class="line">                <span class="comment">// 如果一致，说明tail被删除了，那么需要从头开始遍历 ，如果不一致，那么直接从当前尾节点继续遍历</span></span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 只有offer操作 会执行到这里  </span></span><br><span class="line">                <span class="comment">// 1. 当有两个线程（A B) 竞争时, 如果A 添加了尾节点 ，那么B会在第二次循环时走到这里（因为p.next 已经不为null），此时 p == t  所以 p 指向 q 然后在下一轮更新 赋值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 如果又有C线程竞争 ，因为执行完1后，线程B 在添加尾节点时有竞争失败，那么继续走到这里，此时 p 已经执行 q,即 p != t, 而如果 tail被其他线程改变了，那么p = t(这时的t已经指向了新的tail) 然后开始新一轮的循环</span></span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-Poll-方法"><a href="#4-Poll-方法" class="headerlink" title="4. Poll 方法"></a>4. Poll 方法</h2><p>获取当前队列的第一个节点，并出队 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 元素不为null，出队</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="comment">// head的更新也是滞后的，也就是head的item可以为null，但是head一定不为null</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 p.next == null ，那么说明队列已经空了，直接返回null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明 p节点被其他的线程出队了，重新从head节点查询</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 说明p.next 不为空，那么直接将p节点向后移动一位</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>基本上了解了以上两个方法，就基本可以了解 concurrentLinkedQueue的运行原理 ，其他的一些辅助方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找下一个节点，如果 当前节点被删除，那么重新跳回到头节点</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;E&gt; <span class="title function_">succ</span><span class="params">(Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; next = p.next;</span><br><span class="line">        <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找寻第一个节点，主要用于遍历，和poll的主要不同点在于</span></span><br><span class="line"><span class="comment">// 1. first 方法不删除节点   2. first方法返回的是 Node，而不是 item</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasItem</span> <span class="operator">=</span> (p.item != <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> hasItem ? p : <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38293564/article/details/80798310">Java并发编程之ConcurrentLinkedQueue详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/32d6526494fd">ConcurrentLinkedQueue</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/53582b21bb73">深入理解分析ConcurrentLinkedQueue源码设计</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/05/23/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/23/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/" class="post-title-link" itemprop="url">欧拉回路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-23 22:39:06" itemprop="dateCreated datePublished" datetime="2020-05-23T22:39:06+00:00">2020-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/graph/" itemprop="url" rel="index"><span itemprop="name">graph</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-欧拉回路定义"><a href="#1-欧拉回路定义" class="headerlink" title="1. 欧拉回路定义"></a>1. 欧拉回路定义</h2><p>从一个顶点出发沿着图的边前进，切好经过每条边一次并且回到顶点，我们称为该图是否含有欧拉回路</p>
<p><code>定理一：</code> 连通多重图具有欧拉回路当前仅当他的每个顶点都有偶数度<br><code>定理二：</code> 连通多重图具有欧拉通路当前仅当它恰有两个奇数度顶点</p>
<p>在欧拉通路里，两个具有奇数度的顶点在建立一条虚拟边，那么就可以实现每个顶点都是偶数度，从而形成一条欧拉回路</p>
<h3 id="1-1-欧拉路的判断"><a href="#1-1-欧拉路的判断" class="headerlink" title="1.1 欧拉路的判断"></a>1.1 欧拉路的判断</h3><ol>
<li>判断欧拉通路是否存在的方法</li>
</ol>
<ul>
<li>有向图：图连通，有一个顶点出度比入度大1，有一个顶点入度比出度大1，其余都是出度&#x3D;入度。</li>
<li>无向图：图连通，只有两个顶点是奇数度，其余都是偶数度的。</li>
</ul>
<ol start="2">
<li>判断欧拉回路是否存在的方法</li>
</ol>
<ul>
<li>有向图：图连通，所有的顶点出度&#x3D;入度。</li>
<li>无向图：图连通，所有顶点都是偶数度。</li>
</ul>
<h2 id="2-路径求解"><a href="#2-路径求解" class="headerlink" title="2. 路径求解"></a>2. 路径求解</h2><p>经常会有求欧拉回路的问题， 我们可以使用欧拉回路构造的方式解决</p>
<h3 id="2-1-欧拉回路的构造（Hierholzer算法）"><a href="#2-1-欧拉回路的构造（Hierholzer算法）" class="headerlink" title="2.1 欧拉回路的构造（Hierholzer算法）"></a>2.1 欧拉回路的构造（Hierholzer算法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Euler(G) </span><br><span class="line">    circuit := 从 G 里任意节点开始，连续的遍历该节点的边，直到形成回路</span><br><span class="line">    H := 删除这条回路后剩余的图G</span><br><span class="line">    while H 还存在边</span><br><span class="line">    begin</span><br><span class="line">        subcircuit := 在既是H的顶点也是circuit边的端点处开始的H里找一条回路</span><br><span class="line">        H := 删除subcircuit 的所有边和孤立点之后的H</span><br><span class="line">        circute := 在circute适当顶点插入subcircuit</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    circute 即为所得欧拉回路</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; TODO 待补充图片示例</p>
<h3 id="2-2-佛勒里算法-Fleury"><a href="#2-2-佛勒里算法-Fleury" class="headerlink" title="2.2 佛勒里算法(Fleury)"></a>2.2 佛勒里算法(Fleury)</h3><p>G 为无向图<br> 1、任取G中一个顶点$V_0$(如果是找欧拉通路，那么选任度为奇数的点),使$P_0&#x3D;V_0$<br> 2、假设沿$P_i&#x3D; V_0e_1V_1e_2V_2…e_iV_i$ 走到顶点$v_i$,在下面的步骤中从$E(G) - {e_1e_2…e_i}$中选择$e_{i+1}$</p>
<ul>
<li>$e_{i+1}$ 与 $e_i$ 相关联</li>
<li>除非没有其他选择，否则$e_{i+1}$ 不应该是{$E(G) - {e_1e_2…e_i}$}中的桥</li>
</ul>
<p>3、 当步骤2不能在进行时停止</p>
<h4 id="2-2-1-桥"><a href="#2-2-1-桥" class="headerlink" title="2.2.1 桥"></a>2.2.1 桥</h4><p>设无向图G(V,E)为连通图，若边集$E_l 属于 E$,在图中删除$E_l$所有边后形成的子图为非连通图，而删除$E_l$ 某一子集后得到的子图仍是连通图，那么说明$E_l$是图G的割边集</p>
<p>如果一条边就是那个割边集，那么我们说这条边为<code>割边</code>，或者称之为<code>桥</code></p>
<h4 id="2-2-2-桥的求解算法-TODO"><a href="#2-2-2-桥的求解算法-TODO" class="headerlink" title="2.2.2 桥的求解算法(TODO)"></a>2.2.2 桥的求解算法(TODO)</h4><p>方案一：枚举去掉每个点的情况，DFS判断时间复杂度O(n^2)<br>方案二：Tarjan实现</p>
<h2 id="3-LC示例"><a href="#3-LC示例" class="headerlink" title="3. LC示例"></a>3. LC示例</h2><p>LC753: 破解保险箱</p>
<p>因为该题一定会存在欧拉回路</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crackSafe</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			buf.WriteString(strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buf.String()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录接点是否被访问过</span></span><br><span class="line">	visit := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 0 * (n-1) 开始 遍历</span></span><br><span class="line">	s := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		s += <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 n-1 的0状态开始遍历</span></span><br><span class="line">	dfs753(&amp;buf, visit, s[:], k)</span><br><span class="line">	buf.WriteString(s)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * visit 记录节点是否被访问过</span></span><br><span class="line"><span class="comment"> * s 是当前的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs753</span><span class="params">(buf *bytes.Buffer, visit <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>, s <span class="type">string</span>, k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里用k是因为每个状态的下一个状态都有k中选择，所以直接依次遍历每种情况</span></span><br><span class="line">    <span class="comment">// 如果在其他图中，这个遍历的是和当前状态想关联的边的集合</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		nei := s + strconv.Itoa(i)</span><br><span class="line">		<span class="comment">// 如果已经被访问过，那么继续</span></span><br><span class="line">		<span class="keyword">if</span> visit[nei] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        visit[nei] = <span class="literal">true</span> <span class="comment">// 先记录该点所对应的状态边被访问过</span></span><br><span class="line">        <span class="comment">// 深度遍历以该点为交点的另一连通部分的访问路径</span></span><br><span class="line">        dfs753(buf, visit, nei[<span class="number">1</span>:], k)</span><br><span class="line">        <span class="comment">// 记录下该点</span></span><br><span class="line">		(*buf).WriteString(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/9626163.html">欧拉回路基本概念+判断+求解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/stillxjy/article/details/51956183">欧拉回路路径求解</a></li>
<li><a target="_blank" rel="noopener" href="https://mnmunknown.gitbooks.io/algorithm-notes/content/ou_la_hui_lu_ff0c_hierholzer_suan_fa.html">欧拉回路，Hierholzer算法</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/05/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">拓扑排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-22 23:07:24" itemprop="dateCreated datePublished" datetime="2020-05-22T23:07:24+00:00">2020-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-拓扑排序定义"><a href="#1-拓扑排序定义" class="headerlink" title="1. 拓扑排序定义"></a>1. 拓扑排序定义</h2><p>按照wiki的解释，在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，才能称为该图的一个拓扑排序</p>
<ul>
<li>序列中包含每个顶点，且每个顶点只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul>
<h2 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2. 算法实现"></a>2. 算法实现</h2><h3 id="2-1-卡恩算法"><a href="#2-1-卡恩算法" class="headerlink" title="2.1 卡恩算法"></a>2.1 卡恩算法</h3><p>算法步骤： </p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环</li>
</ol>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L ← 包含已排序的元素的列表，目前为空</span><br><span class="line">S ← 入度为零的节点的集合</span><br><span class="line">当 S 非空时：</span><br><span class="line">    将节点n从S移走</span><br><span class="line">    将n加到L尾部</span><br><span class="line">    选出任意起点为n的边e = (n,m)，移除e。如m没有其它入边(即入度为0)，则将m加入S。</span><br><span class="line">    重复上一步。</span><br><span class="line"></span><br><span class="line">如图中有剩余的边则：</span><br><span class="line">    return error   (图中至少有一个环)</span><br><span class="line">否则： </span><br><span class="line">    return L   (L为图的拓扑排序)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-深度遍历算法"><a href="#2-2-深度遍历算法" class="headerlink" title="2.2 深度遍历算法"></a>2.2 深度遍历算法</h3><p>算法伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">L ← 包含已排序的元素的列表，目前为空</span><br><span class="line">当图中存在未永久标记的节点时：</span><br><span class="line">    选出任何未永久标记的节点n</span><br><span class="line">    visit(n)</span><br><span class="line"></span><br><span class="line">function visit(节点 n)</span><br><span class="line">    如n已有永久标记：</span><br><span class="line">        return 重新选择节点遍历</span><br><span class="line">    如n已有临时标记：</span><br><span class="line">        stop   (不是定向无环图,即有环，需停止)</span><br><span class="line">    将n临时标记</span><br><span class="line">    选出以n为起点的边(n,m)，visit(m)</span><br><span class="line">    重复上一步</span><br><span class="line">    去掉n的临时标记</span><br><span class="line">    将n永久标记</span><br><span class="line">    将n加到L的起始</span><br></pre></td></tr></table></figure>

<h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h2><h3 id="3-1-卡恩算法实现"><a href="#3-1-卡恩算法实现" class="headerlink" title="3.1 卡恩算法实现"></a>3.1 卡恩算法实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 统计各节点的入度</span></span><br><span class="line">	<span class="comment">// 从第一个入度为0的节点出发</span></span><br><span class="line">	<span class="comment">// 查找它的下一个节点，并删除依赖关系</span></span><br><span class="line">    <span class="comment">// 从新找入度为0的节点知道入度为0的节点为空  如果剩余的节点不为空说明有环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前各点的入度</span></span><br><span class="line">	degree := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">		degree[v[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入度为0的点入栈</span></span><br><span class="line">	stack := list.New()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> degree[i] == <span class="number">0</span> &#123;</span><br><span class="line">			stack.PushFront(i)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历栈并处理</span></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> stack.Len() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		top := stack.Front()</span><br><span class="line">		stack.Remove(top)</span><br><span class="line">		topValue := top.Value.(<span class="type">int</span>)</span><br><span class="line">		result = <span class="built_in">append</span>(result, topValue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找前驱节点是栈节点的值，入度减一</span></span><br><span class="line">        <span class="comment">// TODO 实际上这里应该删除入度已经为0的点，不再进行遍历</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">			<span class="keyword">if</span> v[<span class="number">1</span>] == topValue &#123;</span><br><span class="line">				degree[v[<span class="number">0</span>]]--</span><br><span class="line">				<span class="keyword">if</span> degree[v[<span class="number">0</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">					stack.PushFront(v[<span class="number">0</span>])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(result) != numCourses &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-深度遍历算法"><a href="#3-2-深度遍历算法" class="headerlink" title="3.2 深度遍历算法"></a>3.2 深度遍历算法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrderV2</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 从任一为访问过的节点开始	，</span></span><br><span class="line">	<span class="comment">// value= 0:未访问 1:临时访问 2:永久访问</span></span><br><span class="line">    visit := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到节点集合,即每个节点联通的点，进行深度遍历</span></span><br><span class="line">	vGroup := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">		vGroup[v[<span class="number">1</span>]] = <span class="built_in">append</span>(vGroup[v[<span class="number">1</span>]], v[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> visit[i] == <span class="number">0</span> &amp;&amp; !visitOrder(i, &amp;res, vGroup, visit) &#123;</span><br><span class="line">			<span class="comment">// 有环存在</span></span><br><span class="line">			<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(res)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		res[i], res[j] = res[j], res[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度遍历未访问的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visitOrder</span><span class="params">(n <span class="type">int</span>, res *[]<span class="type">int</span>, vGroup <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>, visit <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 已经访问过，无需再访问</span></span><br><span class="line">	<span class="keyword">if</span> visit[n] == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 又访问到临时节点，说明存在环</span></span><br><span class="line">	<span class="keyword">if</span> visit[n] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 有环存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	visit[n] = <span class="number">1</span> <span class="comment">// 先标记临时节点</span></span><br><span class="line">	<span class="keyword">if</span> nodes, ok := vGroup[n]; ok &#123;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">			<span class="keyword">if</span> !visitOrder(m, res, vGroup, visit) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	visit[n] = <span class="number">2</span> <span class="comment">// 标记为永久访问几点，并加入结果集</span></span><br><span class="line">	*res = <span class="built_in">append</span>(*res, n)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F">拓扑排序维基百科</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/05/04/completableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/04/completableFuture/" class="post-title-link" itemprop="url">java CompletableFuture 源码学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-04 17:38:36" itemprop="dateCreated datePublished" datetime="2020-05-04T17:38:36+00:00">2020-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>CompletableFuture 是继FutuerTask之后，JDK1.8 引入的异步执行框架，可以自动检测触发下一级的关联任务，而不需要像 <code>FutureTask</code> 那样通过 <code>get</code> 获取结果后在执行的阻塞方式。<br>‘</p>
<h2 id="1-CompletionStage-接口"><a href="#1-CompletionStage-接口" class="headerlink" title="1. CompletionStage 接口"></a>1. CompletionStage 接口</h2><p>用来表示每个任务执行的一个阶段，通过触发机制，可以在它依赖的任务完成时，执行一些操作和计算 <code>CompletableFuture</code> 继承自CompletionStage 用来控制类的执行</p>
<h3 id="1-1-接口包含的方法"><a href="#1-1-接口包含的方法" class="headerlink" title="1.1 接口包含的方法"></a>1.1 接口包含的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将上一个stage的结果转化成新的类型或值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收上一个的结果值并进行处理,，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上一个stage有结果后，执行一段新的操作,，无返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="comment">// 结合两个CompletableStage的结果，转化成新的类型或值</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletionStage&lt;V&gt; <span class="title function_">thenCombine</span> <span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span>;</span><br><span class="line"><span class="comment">// 等待两个stage都返回后在使用两个结果值进行处理</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; <span class="title function_">thenAcceptBoth</span> <span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; action)</span>;</span><br><span class="line"><span class="comment">// 等两个stage都执行完之后，在执行action</span></span><br><span class="line"> <span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="comment">// 任何一个stage结束后，就触发fn操作</span></span><br><span class="line"> <span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">applyToEither</span> <span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span>;</span><br><span class="line"><span class="comment">// 任何一个stage结束后，就接收该stage的结果处理</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">acceptEither</span> <span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="comment">// 任何一个stage结束后，就结构该stage的结果进行下一步处理</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br><span class="line"><span class="comment">// 返回一个新的CompletableStage，并将上一个stage的结果作为新的stage的supplier</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span>;</span><br><span class="line"><span class="comment">// stage完成后，接收结果并返回另一个stage,在action中处理接收的结果和异常</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span>;</span><br><span class="line"><span class="comment">// 统一了对正常结果和异常结果的处理 和whenComplete不同的是这个仍返回他们的原来的completage</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">handle</span> <span class="params">(BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当运算过程中遇到异常时的一个补偿处理 ， 合理处理异常返回</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title function_">exceptionally</span> <span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">toCompletableFuture</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了exceptionally，toCompletableFuture 方法外，其他的都有另外两个变体方法，以Async结尾的使用默认的线程池异步执行  以及另一个添加自定义线程池的异步执行</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-Complation-类"><a href="#1-2-Complation-类" class="headerlink" title="1.2 Complation 类"></a>1.2 Complation 类</h2><p>继承自 <code>ForkJoinTask</code>和 <code>Runnable</code> , 代表了一个执行单元， 用来做具体的逻辑</p>
<p>CompletableFuture中的数据结构为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> Object result;       <span class="comment">// Either the result or boxed AltResult</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;    <span class="comment">// Top of Treiber stack of dependent actions</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Completion</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AsynchronousCompletionTask &#123;</span><br><span class="line">    <span class="keyword">volatile</span> Completion next;      <span class="comment">// Treiber stack link</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs completion action if triggered, returning a</span></span><br><span class="line"><span class="comment">     * dependent that may need propagation, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode SYNC, ASYNC, or NESTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if possibly still triggerable. Used by cleanStack. */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isLive</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>                &#123; tryFire(ASYNC); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span>            &#123; tryFire(ASYNC); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title function_">getRawResult</span><span class="params">()</span>       &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(Void v)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 <code>CompletableFuture</code> 包含了一个 <code>stack&#123;Complation&#125;</code>, 而在 <code>Complation</code> 中又包含了 <code>next&#123;Compation&#125;</code>,依据 <code>UniCompletion</code> 的结构 ,形成了如下的数据结构：</p>
<p><img src="/../images/ComplatebleFutureStruct.png" alt="ComplatebleFutre 结构"></p>
<p>节点的执行顺序是先执行stack的第一个元素，如果节点的第一个元素完成，那么执行第一个节点下的CompetableFuture的最后一个元素，然后在执行倒数第二个元素，等该 <code>列</code> 检测执行完后，会执行该 <code>行</code> 的第二个元素(如果该行的第一个元素为执行完，那么在异步的情况下会直接检测该行的第二个元素)</p>
<p><img src="/../images/ComplatebleFutureStruct02.png" alt="ComplatebleFutre 结构"></p>
<p><code>Completion</code> 有3个直接子类， CoCompletion，Signaller和UniCompletion.</p>
<ol>
<li>CoCompletion 主要是作为 BiCompletion 的代理类，而BiCompletion 继承自 UniCompletion, 即 CoComplation 封装了BiComplation的实现（可能为为了与UniCompletion 区分隔离？）</li>
<li>Signaller 只在 timeGet 和 watingGet的时候使用过，主要是添加到stack的尾部，当当前任务完成时通过调用postComplete从而解除Signaller中的park的来标识任务已完成并通知下游，返回结果</li>
<li>UniCompletion  具体的任务实现父类</li>
</ol>
<h2 id="1-3-UniCompletion"><a href="#1-3-UniCompletion" class="headerlink" title="1.3 UniCompletion"></a>1.3 UniCompletion</h2><p>在CompletableFuture 中， 任务分3类，一类是无入参， 一类是只有一个入参，一类是有两个入参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UniCompletion</span>&lt;T,V&gt; <span class="keyword">extends</span> <span class="title class_">Completion</span> &#123;</span><br><span class="line">        <span class="comment">// 是否使用自定义的线程池,默认使用commonPool</span></span><br><span class="line">        Executor executor;                 <span class="comment">// executor to use (null if none)</span></span><br><span class="line">        <span class="comment">// 依赖的类</span></span><br><span class="line">        CompletableFuture&lt;V&gt; dep;          <span class="comment">// the dependent to complete</span></span><br><span class="line">        <span class="comment">// 被依赖的类</span></span><br><span class="line">        CompletableFuture&lt;T&gt; src;          <span class="comment">// source for action</span></span><br><span class="line">        <span class="comment">// 例如 A.thenApply(B)  那么我们认为A是被依赖类而B是依赖类，当A完成时会触发B类的执行</span></span><br><span class="line"></span><br><span class="line">        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                      CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">            <span class="built_in">this</span>.executor = executor; <span class="built_in">this</span>.dep = dep; <span class="built_in">this</span>.src = src;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if action can be run. Call only when known to</span></span><br><span class="line"><span class="comment">         * be triggerable. Uses FJ tag bit to ensure that only one</span></span><br><span class="line"><span class="comment">         * thread claims ownership.  If async, starts as task -- a</span></span><br><span class="line"><span class="comment">         * later call to tryFire will run action.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">claim</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Executor</span> <span class="variable">e</span> <span class="operator">=</span> executor;</span><br><span class="line">            <span class="comment">// 保证只会有一个线程执行，如果是同步的那么直接返回true，如果以异步，那么走自定义线程池执行</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="type">short</span>)<span class="number">0</span>, (<span class="type">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                executor = <span class="literal">null</span>; <span class="comment">// disable</span></span><br><span class="line">                e.execute(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是否已经被执行</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLive</span><span class="params">()</span> &#123; <span class="keyword">return</span> dep != <span class="literal">null</span>; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-无入参类任务"><a href="#1-3-1-无入参类任务" class="headerlink" title="1.3.1 无入参类任务"></a>1.3.1 无入参类任务</h3><p>这类任务主要是 <code>CompletetableFuture</code> 的入口类，默认都为异步执行, 直接继承自 <code>ForkJoinTask</code></p>
<p>以 <code>supplyAsync</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">asyncSupplyStage</span><span class="params">(Executor e,</span></span><br><span class="line"><span class="params">                                                     Supplier&lt;U&gt; f)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;U&gt;();</span><br><span class="line">        <span class="comment">// 创建任务后直接执行，不依赖其他任务</span></span><br><span class="line">        e.execute(<span class="keyword">new</span> <span class="title class_">AsyncSupply</span>&lt;U&gt;(d, f));</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncSupply</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AsynchronousCompletionTask &#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;</span><br><span class="line">        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">            <span class="built_in">this</span>.dep = dep; <span class="built_in">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title function_">getRawResult</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setRawResult</span><span class="params">(Void v)</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123; run(); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="literal">null</span> &amp;&amp; (f = fn) != <span class="literal">null</span>) &#123;</span><br><span class="line">                dep = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        d.completeValue(f.get());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行完成后向后传递给依赖的任务</span></span><br><span class="line">                d.postComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-只有一个入参的任务"><a href="#1-3-2-只有一个入参的任务" class="headerlink" title="1.3.2  只有一个入参的任务"></a>1.3.2  只有一个入参的任务</h3><p>继承自 <code>Completaion</code>, 依赖于上一个任务的完成，然后触发该任务 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UniApply in CompletableFuture </span><br><span class="line">UniWhenComplete in CompletableFuture </span><br><span class="line">UniCompose in CompletableFuture </span><br><span class="line">UniExceptionally in CompletableFuture </span><br><span class="line">UniAccept in CompletableFuture </span><br><span class="line">UniRun in CompletableFuture </span><br><span class="line">UniHandle in CompletableFuture </span><br><span class="line">UniRelay in CompletableFuture </span><br></pre></td></tr></table></figure>

<p>以 UniApply 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">        Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="title function_">uniApplyStage</span><span class="params">(</span></span><br><span class="line"><span class="params">        Executor e, Function&lt;? <span class="built_in">super</span> T,? extends V&gt; f)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        CompletableFuture&lt;V&gt; d =  <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;V&gt;();</span><br><span class="line">        <span class="comment">// 判断任务是否为异步或者已经被执行完成</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> || !d.uniApply(<span class="built_in">this</span>, f, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创新新的任务，并与当前任务建立依赖</span></span><br><span class="line">            UniApply&lt;T,V&gt; c = <span class="keyword">new</span> <span class="title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="built_in">this</span>, f);</span><br><span class="line">            <span class="comment">// 将当前任务放置到stack的队头（这也是为什么后添加的会先执行)</span></span><br><span class="line">            push(c);</span><br><span class="line">            <span class="comment">// 再次检测是否可以被执行（为何需要再次被检测原因在于如果在push过程中，被依赖的任务完成了</span></span><br><span class="line">            <span class="comment">// 从而未触发该任务，那么需要tryFire()来触发） 使用同步方式，即在当前线程中检测</span></span><br><span class="line">            c.tryFire(SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UniApply</span>&lt;T,V&gt; <span class="keyword">extends</span> <span class="title class_">UniCompletion</span>&lt;T,V&gt; &#123;</span><br><span class="line">        Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn;</span><br><span class="line">        UniApply(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                 CompletableFuture&lt;T&gt; src,</span><br><span class="line">                 Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn) &#123;</span><br><span class="line">            <span class="built_in">super</span>(executor, dep, src); <span class="built_in">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;V&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">            CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> ||</span><br><span class="line">                <span class="comment">// mode &gt; 0 代表的是异步状态，一般被forkjoin steal时被异步调用，或者是同步调用时，通过c.claim()而被自定义线程池异步调用. </span></span><br><span class="line">                <span class="comment">// 这里之所以这样涉及是保证在同步状态执行可以可以通过c.claim() 来确保只有一个线程执行，并快速返回</span></span><br><span class="line">                <span class="comment">// 而如果mode大于0的话，代表的是另外一个线程执行来该任务（非创建UniApply的线程）</span></span><br><span class="line">                !d.uniApply(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 因为在同步状态下只会有一个线程被允许执行，当允许被执行后，清空当前的数据变量，便于回收和后期处理判断</span></span><br><span class="line">            dep = <span class="literal">null</span>; src = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="type">boolean</span> <span class="title function_">uniApply</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span><br><span class="line"><span class="params">                               Function&lt;? <span class="built_in">super</span> S,? extends T&gt; f,</span></span><br><span class="line"><span class="params">                               UniApply&lt;S,T&gt; c)</span> &#123;</span><br><span class="line">        Object r; Throwable x;</span><br><span class="line">        <span class="comment">// 如果被依赖任务没有完成，那么直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断任务是否产生异常</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在mode &lt;= 0 状态下，保证只会有一个线程获得运行权限</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">S</span> <span class="variable">s</span> <span class="operator">=</span> (S) r;</span><br><span class="line">                completeValue(f.apply(s));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-有两个入参的任务-BiCompletion"><a href="#1-3-3-有两个入参的任务-BiCompletion" class="headerlink" title="1.3.3 有两个入参的任务 BiCompletion"></a>1.3.3 有两个入参的任务 BiCompletion</h3><p>有两个入参的任务，依赖于两个任务共同作用或其中的任何一个生效来控制任务流的进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OrRun in CompletableFuture </span><br><span class="line">BiAccept in CompletableFuture </span><br><span class="line">BiApply in CompletableFuture </span><br><span class="line">OrRelay in CompletableFuture </span><br><span class="line">OrAccept in CompletableFuture </span><br><span class="line">OrApply in CompletableFuture </span><br><span class="line">BiRun in CompletableFuture </span><br><span class="line">BiRelay in CompletableFuture </span><br></pre></td></tr></table></figure>

<p>我们以 <code>BiApply</code> 和 <code>OrApply</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 结合两个CompletionStage的结果共同作用</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends U&gt; other,</span></span><br><span class="line"><span class="params">        BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> biApplyStage(<span class="literal">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">biApplyStage</span><span class="params">(</span></span><br><span class="line"><span class="params">        Executor e, CompletionStage&lt;U&gt; o,</span></span><br><span class="line"><span class="params">        BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; f)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;U&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span> || (b = o.toCompletableFuture()) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;V&gt;();</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> || !d.biApply(<span class="built_in">this</span>, b, f, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// d任务依赖于this, b 两个任务的同时完成后才可执行</span></span><br><span class="line">            BiApply&lt;T,U,V&gt; c = <span class="keyword">new</span> <span class="title class_">BiApply</span>&lt;T,U,V&gt;(e, d, <span class="built_in">this</span>, b, f);</span><br><span class="line">            <span class="comment">// 将c 任务分别放置到当前任务和b任务的队列头部 即当b任务和当前任务完成是都会触发c任务的状态检测</span></span><br><span class="line">            bipush(b, c);</span><br><span class="line">            c.tryFire(SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Pushes completion to this and b unless both done. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bipush</span><span class="params">(CompletableFuture&lt;?&gt; b, BiCompletion&lt;?,?,?&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">        Object r;</span><br><span class="line">        <span class="keyword">while</span> ((r = result) == <span class="literal">null</span> &amp;&amp; !tryPushStack(c))</span><br><span class="line">            lazySetNext(c, <span class="literal">null</span>); <span class="comment">// clear on failure</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b != <span class="built_in">this</span> &amp;&amp; b.result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Completion</span> <span class="variable">q</span> <span class="operator">=</span> (r != <span class="literal">null</span>) ? c : <span class="keyword">new</span> <span class="title class_">CoCompletion</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (b.result == <span class="literal">null</span> &amp;&amp; !b.tryPushStack(q))</span><br><span class="line">                lazySetNext(q, <span class="literal">null</span>); <span class="comment">// clear on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BiApply</span>&lt;T,U,V&gt; <span class="keyword">extends</span> <span class="title class_">BiCompletion</span>&lt;T,U,V&gt; &#123;</span><br><span class="line">        BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn;</span><br><span class="line">        BiApply(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,</span><br><span class="line">                BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn) &#123;</span><br><span class="line">            <span class="comment">// 针对于dep建立两个依赖 </span></span><br><span class="line">            <span class="built_in">super</span>(executor, dep, src, snd); <span class="built_in">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;V&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">            CompletableFuture&lt;V&gt; d;</span><br><span class="line">            CompletableFuture&lt;T&gt; a;</span><br><span class="line">            CompletableFuture&lt;U&gt; b;</span><br><span class="line">            <span class="comment">// 如果当前任务已经被执行过，那么直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> ||</span><br><span class="line">                !d.biApply(a = src, b = snd, fn, mode &gt; <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            dep = <span class="literal">null</span>; src = <span class="literal">null</span>; snd = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Post-processing after successful BiCompletion tryFire. */</span></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;T&gt; <span class="title function_">postFire</span><span class="params">(CompletableFuture&lt;?&gt; a,</span></span><br><span class="line"><span class="params">                                        CompletableFuture&lt;?&gt; b, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.stack != <span class="literal">null</span>) &#123; <span class="comment">// clean second source</span></span><br><span class="line">        <span class="comment">//嵌套模式下或者任务未完成，那么清理队列中的无效节点</span></span><br><span class="line">            <span class="keyword">if</span> (mode &lt; <span class="number">0</span> || b.result == <span class="literal">null</span>)</span><br><span class="line">                b.cleanStack();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 向下传递</span></span><br><span class="line">                b.postComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postFire(a, mode);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-processing by dependent after successful UniCompletion</span></span><br><span class="line"><span class="comment"> * tryFire.  Tries to clean stack of source a, and then either runs</span></span><br><span class="line"><span class="comment"> * postComplete or returns this to caller, depending on mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;T&gt; <span class="title function_">postFire</span><span class="params">(CompletableFuture&lt;?&gt; a, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span> &amp;&amp; a.stack != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span> || a.result == <span class="literal">null</span>)</span><br><span class="line">            a.cleanStack();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.postComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; stack != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            postComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> &lt;R,S&gt; <span class="type">boolean</span> <span class="title function_">biApply</span><span class="params">(CompletableFuture&lt;R&gt; a,</span></span><br><span class="line"><span class="params">                                CompletableFuture&lt;S&gt; b,</span></span><br><span class="line"><span class="params">                                BiFunction&lt;? <span class="built_in">super</span> R,? <span class="built_in">super</span> S,? extends T&gt; f,</span></span><br><span class="line"><span class="params">                                BiApply&lt;R,S,T&gt; c)</span> &#123;</span><br><span class="line">        Object r, s; Throwable x;</span><br><span class="line">        <span class="comment">// 如果 a b都未完成那么返回false</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> ||</span><br><span class="line">            b == <span class="literal">null</span> || (s = b.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        tryComplete: <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)s).ex) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, s);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                s = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 同步状态下检测，保证只有一个线程获取权限</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">R</span> <span class="variable">rr</span> <span class="operator">=</span> (R) r;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">S</span> <span class="variable">ss</span> <span class="operator">=</span> (S) s;</span><br><span class="line">                completeValue(f.apply(rr, ss));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------OrApply-------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orApplyStage(<span class="literal">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OrApply</span>&lt;T,U <span class="keyword">extends</span> <span class="title class_">T</span>,V&gt; <span class="keyword">extends</span> <span class="title class_">BiCompletion</span>&lt;T,U,V&gt; &#123;</span><br><span class="line">        Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn;</span><br><span class="line">        OrApply(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                CompletableFuture&lt;T&gt; src,</span><br><span class="line">                CompletableFuture&lt;U&gt; snd,</span><br><span class="line">                Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; fn) &#123;</span><br><span class="line">            <span class="built_in">super</span>(executor, dep, src, snd); <span class="built_in">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;V&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">            CompletableFuture&lt;V&gt; d;</span><br><span class="line">            CompletableFuture&lt;T&gt; a;</span><br><span class="line">            CompletableFuture&lt;U&gt; b;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> ||</span><br><span class="line">                !d.orApply(a = src, b = snd, fn, mode &gt; <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            dep = <span class="literal">null</span>; src = <span class="literal">null</span>; snd = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> &lt;R,S <span class="keyword">extends</span> <span class="title class_">R</span>&gt; <span class="type">boolean</span> <span class="title function_">orApply</span><span class="params">(CompletableFuture&lt;R&gt; a,</span></span><br><span class="line"><span class="params">                                      CompletableFuture&lt;S&gt; b,</span></span><br><span class="line"><span class="params">                                      Function&lt;? <span class="built_in">super</span> R, ? extends T&gt; f,</span></span><br><span class="line"><span class="params">                                      OrApply&lt;R,S,T&gt; c)</span> &#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        ((r = a.result) == <span class="literal">null</span> &amp;&amp; (r = b.result) == <span class="literal">null</span>) || f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tryComplete: <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    completeThrowable(x, r);</span><br><span class="line">                    <span class="keyword">break</span> tryComplete;</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">R</span> <span class="variable">rr</span> <span class="operator">=</span> (R) r;</span><br><span class="line">            completeValue(f.apply(rr));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U <span class="keyword">extends</span> <span class="title class_">T</span>,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">orApplyStage</span><span class="params">(</span></span><br><span class="line"><span class="params">    Executor e, CompletionStage&lt;U&gt; o,</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends V&gt; f)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;U&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span> || (b = o.toCompletableFuture()) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;V&gt;();</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> || !d.orApply(<span class="built_in">this</span>, b, f, <span class="literal">null</span>)) &#123;</span><br><span class="line">        OrApply&lt;T,U,V&gt; c = <span class="keyword">new</span> <span class="title class_">OrApply</span>&lt;T,U,V&gt;(e, d, <span class="built_in">this</span>, b, f);</span><br><span class="line">        orpush(b, c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-基础的公共方法"><a href="#2-基础的公共方法" class="headerlink" title="2. 基础的公共方法"></a>2. 基础的公共方法</h2><p>任务传递依赖 <code>postComplete</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops and tries to trigger all reachable dependents.  Call only</span></span><br><span class="line"><span class="comment"> * when known to be done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">postComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On each step, variable f holds current dependents to pop</span></span><br><span class="line"><span class="comment">     * and run.  It is extended along only one path at a time,</span></span><br><span class="line"><span class="comment">     * pushing others to avoid unbounded recursion.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CompletableFuture&lt;?&gt; f = <span class="built_in">this</span>; Completion h;</span><br><span class="line">    <span class="comment">// 检测f栈是否为空</span></span><br><span class="line">    <span class="keyword">while</span> ((h = f.stack) != <span class="literal">null</span> ||</span><br><span class="line">           (f != <span class="built_in">this</span> &amp;&amp; (h = (f = <span class="built_in">this</span>).stack) != <span class="literal">null</span>)) &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; d; Completion t;</span><br><span class="line">        <span class="comment">// 如果f栈不为空，那么h出栈</span></span><br><span class="line">        <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123; <span class="comment">// 如果出栈的h不是最后一个元素，则判断f是否为当前的completablefuture</span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="built_in">this</span>) &#123; <span class="comment">// f 不是 this, 那么需要将 h 推送到当前this栈的栈顶，然后继续遍历f知道f的stack元素为空</span></span><br><span class="line">                    pushStack(h);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h.next = <span class="literal">null</span>;    <span class="comment">// detach 消除h的指针依赖，helpful for gc</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// f栈的最后一个元素或者就是this栈中的元素</span></span><br><span class="line">            <span class="comment">// 以嵌套的方式来检测任务是否可以被执行, 在嵌套模式下， 1. mode &lt; 0 在 ``mode &gt; 0 ? null : this `` 传递的是this指针，</span></span><br><span class="line">            <span class="comment">// 1. 如果h任务是以异步方式执行的，那么这里会返回null， 从而不会在检测h下相关的任务，</span></span><br><span class="line">            <span class="comment">// 2. 如果h任务是同步方式，那么会同步执行完h之后，返回h所在的CompletableFuture, 来获取h相关的stack数据</span></span><br><span class="line">            f = (d = h.tryFire(NESTED)) == <span class="literal">null</span> ? <span class="built_in">this</span> : d; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cleanStack</code> 清空栈内已经失效的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Traverses stack and unlinks dead Completions. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cleanStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Completion</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>, q = stack; q != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="type">Completion</span> <span class="variable">s</span> <span class="operator">=</span> q.next;</span><br><span class="line">        <span class="comment">// 当前节点存活，那么使p指向q,而q指向他的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (q.isLive()) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p==null, 代表q.isLive == false. 即用s代替q，然后让q重新指向stack</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            casStack(q, s); <span class="comment">// 将q出栈</span></span><br><span class="line">            q = stack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果q不存活，并且p不为null，说明q已死亡，且当前已经找到过存活的元素。p指向q的下一个元素s，从而将q出栈</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = s;</span><br><span class="line">            <span class="keyword">if</span> (p.isLive()) <span class="comment">// 判断p是否存活，而p只能是null或者最近一个存活的Completion</span></span><br><span class="line">                q = s;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="literal">null</span>;  <span class="comment">// restart</span></span><br><span class="line">                q = stack; <span class="comment">// 开始新一轮的栈清空处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allOf</code> 等待所有任务的完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** Recursively constructs a tree of completions. */</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">andTree</span><span class="params">(CompletableFuture&lt;?&gt;[] cfs,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;Void&gt;();</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="comment">// empty</span></span><br><span class="line">        d.result = NIL;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; a, b;</span><br><span class="line">        <span class="comment">// 采用二分递归的方式，来进行判断 </span></span><br><span class="line">        <span class="comment">// biRelay 用来判断当前的俩个任务是否完成</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a = (lo == mid ? cfs[lo] :</span><br><span class="line">                  andTree(cfs, lo, mid))) == <span class="literal">null</span> ||</span><br><span class="line">            (b = (lo == hi ? a : (hi == mid+<span class="number">1</span>) ? cfs[hi] :</span><br><span class="line">                  andTree(cfs, mid+<span class="number">1</span>, hi)))  == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (!d.biRelay(a, b)) &#123;</span><br><span class="line">            BiRelay&lt;?,?&gt; c = <span class="keyword">new</span> <span class="title class_">BiRelay</span>&lt;&gt;(d, a, b);</span><br><span class="line">            <span class="comment">// 将c分别放进 a b的执行队列中，保证a b完成后触发c的检查</span></span><br><span class="line">            a.bipush(b, c);</span><br><span class="line">            c.tryFire(SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BiRelay</span>&lt;T,U&gt; <span class="keyword">extends</span> <span class="title class_">BiCompletion</span>&lt;T,U,Void&gt; &#123; <span class="comment">// for And</span></span><br><span class="line">    BiRelay(CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">            CompletableFuture&lt;T&gt; src,</span><br><span class="line">            CompletableFuture&lt;U&gt; snd) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>, dep, src, snd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; d;</span><br><span class="line">        CompletableFuture&lt;T&gt; a;</span><br><span class="line">        CompletableFuture&lt;U&gt; b;</span><br><span class="line">        <span class="comment">// 判断任务是否执行过</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> || !d.biRelay(a = src, b = snd))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        src = <span class="literal">null</span>; snd = <span class="literal">null</span>; dep = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">biRelay</span><span class="params">(CompletableFuture&lt;?&gt; a, CompletableFuture&lt;?&gt; b)</span> &#123;</span><br><span class="line">    Object r, s; Throwable x;</span><br><span class="line">    <span class="comment">// 只要有一个为完成，那么就返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> ||</span><br><span class="line">        b == <span class="literal">null</span> || (s = b.result) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="literal">null</span>)</span><br><span class="line">            completeThrowable(x, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)s).ex) != <span class="literal">null</span>)</span><br><span class="line">            completeThrowable(x, s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            completeNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>anyOf</code> 等待任一任务完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Recursively constructs a tree of completions. */</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">orTree</span><span class="params">(CompletableFuture&lt;?&gt;[] cfs,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Object&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; a, b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a = (lo == mid ? cfs[lo] :</span><br><span class="line">                  orTree(cfs, lo, mid))) == <span class="literal">null</span> ||</span><br><span class="line">            (b = (lo == hi ? a : (hi == mid+<span class="number">1</span>) ? cfs[hi] :</span><br><span class="line">                  orTree(cfs, mid+<span class="number">1</span>, hi)))  == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (!d.orRelay(a, b)) &#123;</span><br><span class="line">            OrRelay&lt;?,?&gt; c = <span class="keyword">new</span> <span class="title class_">OrRelay</span>&lt;&gt;(d, a, b);</span><br><span class="line">            a.orpush(b, c);</span><br><span class="line">            c.tryFire(SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OrRelay</span>&lt;T,U&gt; <span class="keyword">extends</span> <span class="title class_">BiCompletion</span>&lt;T,U,Object&gt; &#123; <span class="comment">// for Or</span></span><br><span class="line">    OrRelay(CompletableFuture&lt;Object&gt; dep, CompletableFuture&lt;T&gt; src,</span><br><span class="line">            CompletableFuture&lt;U&gt; snd) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>, dep, src, snd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Object&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Object&gt; d;</span><br><span class="line">        CompletableFuture&lt;T&gt; a;</span><br><span class="line">        CompletableFuture&lt;U&gt; b;</span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> || !d.orRelay(a = src, b = snd))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        src = <span class="literal">null</span>; snd = <span class="literal">null</span>; dep = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">orRelay</span><span class="params">(CompletableFuture&lt;?&gt; a, CompletableFuture&lt;?&gt; b)</span> &#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        ((r = a.result) == <span class="literal">null</span> &amp;&amp; (r = b.result) == <span class="literal">null</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        completeRelay(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get和join方法都会在获取不到结果是按条件轮循watingGet方法, 只是join被中断是会抛出异常，而get可以返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">waitingGet</span><span class="params">(<span class="type">boolean</span> interruptible)</span> &#123;</span><br><span class="line">    <span class="type">Signaller</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">while</span> ((r = result) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//初始化自旋次数</span></span><br><span class="line">            spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// Use brief spin-wait on multiprocessors</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果spins大于0 那么继续自旋</span></span><br><span class="line">            <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//停止自旋后,如果result依旧是null，则对q进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">Signaller</span>(interruptible, <span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="comment">// 未入栈时，将q放入到栈中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = tryPushStack(q);</span><br><span class="line">        <span class="comment">// 扰动信号匹配，将q的有关字段全部置空，顺带清一下栈，返回null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// thread == null 会代表该节点不再存活，需要被清理调</span></span><br><span class="line">            q.thread = <span class="literal">null</span>;</span><br><span class="line">            cleanStack();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//q关联的线程存在，即q存活，且依旧没有执行完毕，使用ForkJoinPool的阻塞管理机制，q的策略进行阻塞。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="literal">null</span> &amp;&amp; result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ForkJoinPool.managedBlock(q);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">//被中断时会将q的扰动控制信号设置为-1</span></span><br><span class="line">                q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">        q.thread = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptible)</span><br><span class="line">                r = <span class="literal">null</span>; <span class="comment">// report interruption</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 置中断位，</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //当前future已经有结果，进行postComplete逻辑并返回r。</span></span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; TODO 待分析方法  get join get(time, timeUnit)</p>
<h2 id="3-参考链接："><a href="#3-参考链接：" class="headerlink" title="3. 参考链接："></a>3. 参考链接：</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019484482">https://segmentfault.com/a/1190000019484482</a><br><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/712258">https://yq.aliyun.com/articles/712258</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aniao/p/aniao_cf.html">https://www.cnblogs.com/aniao/p/aniao_cf.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/04/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">回溯算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-26 17:34:10" itemprop="dateCreated datePublished" datetime="2020-04-26T17:34:10+00:00">2020-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">参考</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2020/04/19/%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/19/%E5%8D%95%E8%B0%83%E6%A0%88/" class="post-title-link" itemprop="url">单调栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 22:44:22" itemprop="dateCreated datePublished" datetime="2020-04-19T22:44:22+00:00">2020-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>单调栈： 栈内元素是单调递增或单调递减的栈，只在栈顶进行操作。 时间复杂度为O(n) 即所有元素只进栈一次</p>
<p>性质：1). 栈具有单调性 2). 元素入栈前会把破坏单调性的元素出栈，</p>
<h2 id="2-详细示例以及算法解析"><a href="#2-详细示例以及算法解析" class="headerlink" title="2. 详细示例以及算法解析"></a>2. 详细示例以及算法解析</h2><h3 id="2-1-LC42-接雨水问题"><a href="#2-1-LC42-接雨水问题" class="headerlink" title="2.1 LC42 接雨水问题"></a>2.1 LC42 接雨水问题</h3><p>业务场景为只要两个柱子之间形成凹槽，那么就可以存储水，也就是只要入栈的元素高度大于栈顶元素，那么就可以存水。 这是个单调递减栈，元素小于栈顶元素才可入栈</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trapV2</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	area := <span class="number">0</span></span><br><span class="line">	stack := list.New()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> height &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			top := stack.Front()</span><br><span class="line">			<span class="keyword">if</span> top == <span class="literal">nil</span> || height[i] &lt; height[top.Value.(<span class="type">int</span>)] &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			stack.Remove(top)</span><br><span class="line">			bottom := top.Value.(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果栈顶的元素相同，那么只保留最后一个就可以，因为他们存储的大小一致</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> stack.Front() == <span class="literal">nil</span> || height[stack.Front().Value.(<span class="type">int</span>)] != height[bottom] &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				stack.Remove(stack.Front())</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将要入栈的元素大于栈顶元素 出栈并计算面积</span></span><br><span class="line">			<span class="comment">// 取两侧柱子的最小高度 - 已经计算的高度 = 剩下的可以被填充的高度</span></span><br><span class="line">			<span class="keyword">if</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				top = stack.Front()</span><br><span class="line">				area += (Min(height[i], height[top.Value.(<span class="type">int</span>)]) - height[bottom]) * (i - top.Value.(<span class="type">int</span>) - <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.PushFront(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-暴力求解法"><a href="#2-1-1-暴力求解法" class="headerlink" title="2.1.1 暴力求解法"></a>2.1.1 暴力求解法</h4><p>每个位置能存水的最大高度为当前注册两侧的最大值中的最小值减去当前柱子的高度，即为他能存水的高度。 伪代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">0</span> ; j &lt;i; i ++ &#123;</span><br><span class="line">		leftMax = max(leftMax,height[j])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j = i + <span class="number">1</span> ; j &lt; heights.<span class="built_in">len</span>; i ++ &#123;</span><br><span class="line">		rightMax = max(rightMax,height[j])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	area += min(leftMax,rightMax) - height[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-动态规划法"><a href="#2-1-2-动态规划法" class="headerlink" title="2.1.2 动态规划法"></a>2.1.2 动态规划法</h4><p>该算法是在暴力破解法之上的优化，从上面的处理逻辑可以看到，计算所有两侧的告诉时，有很多都被重复计算，因此可以将中间结果记录下来<br>dp[i][0] 代表i左侧的最大高度<br>dp[i][1] 代表i右侧的最大高度<br>伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">l := <span class="built_in">len</span>(height)</span><br><span class="line">dp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = height[<span class="number">0</span>] </span><br><span class="line">dp[l][<span class="number">1</span>] = dp[l]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>],height[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i &lt; l &#123;</span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i + <span class="number">1</span>][<span class="number">1</span>],height[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line"></span><br><span class="line">	area += min(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]) - height[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-双指针移动法"><a href="#2-1-3-双指针移动法" class="headerlink" title="2.1.3 双指针移动法"></a>2.1.3 双指针移动法</h4><p>左右双指针移动，柱矮的移动，（如果柱高的移动，那么会造成有部分没有计算，因为存水的面积是有柱子的高度决定的）。</p>
<p>由 area &#x3D; min(dp[i][0] , dp[i][1]) - height[i] 得：</p>
<p>area &#x3D; min(leftMax,rightMax) - height[i] , 所以让柱矮的移动，然后不断比对取两侧比较矮的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(heights)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> leftMax &lt; rightMax &#123;</span><br><span class="line">		leftMax = max(leftMax, heights[left])</span><br><span class="line">		area += leftMax - height[left]</span><br><span class="line">		left++</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		rightMax = max(rightMax, height[right])</span><br><span class="line">		area += rightMax - heights[right]</span><br><span class="line">		right--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-LC-84-柱状图中最大的矩形"><a href="#2-2-LC-84-柱状图中最大的矩形" class="headerlink" title="2.2 LC 84 柱状图中最大的矩形"></a>2.2 LC 84 柱状图中最大的矩形</h3><p>同接雨水问题相关，如果入栈的元素小于栈顶元素，那么栈顶出栈并迭代计算当前的最大面积。 只有当元素大于栈顶元素时才入栈。<br>如果栈为空，那么代表元素的左侧都大于改元素，那么此时的左侧面积为 height[index] * i</p>
<p>否则左侧组成的面积大小为 height[index] * (i - left_i - 1), 原因： 左侧和右侧的元素一定都小于当前的height[index] 但是这俩之间的元素值一定大于当前的height[index],因为比它大的都出栈了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 末尾追加0，是因为如果是生序的话，保证最终能有个值兜底去计算其他的值</span></span><br><span class="line">	heights = <span class="built_in">append</span>(heights, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	area := <span class="number">0</span></span><br><span class="line">	stack := list.New()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 保持栈顶小于当前元素</span></span><br><span class="line">			<span class="comment">// 如果不小于，那么移除栈顶，计算当前高度的最大面积，否则直接入栈，因为添加了末尾元素0，所以即便是连续的递增，最终也会被计算</span></span><br><span class="line">			f := stack.Front()</span><br><span class="line">			<span class="keyword">if</span> f == <span class="literal">nil</span> || heights[f.Value.(<span class="type">int</span>)] &lt; heights[i] &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			tArea := <span class="number">0</span></span><br><span class="line">			stack.Remove(f)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取当前的栈顶元素，来求解以当前为高度的元素的跨度</span></span><br><span class="line">			top := f.Value.(<span class="type">int</span>)</span><br><span class="line">			<span class="keyword">if</span> stack.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				tArea = heights[top] * i</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tArea = heights[top] * (i - stack.Front().Value.(<span class="type">int</span>) - <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tArea &gt; area &#123;</span><br><span class="line">				area = tArea</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.PushFront(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-暴力算法"><a href="#2-2-1-暴力算法" class="headerlink" title="2.2.1 暴力算法"></a>2.2.1 暴力算法</h4><p>计算以每个柱子为高，他能向外扩展的最大长度组成的矩形即为该柱可以形成的最大面积</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line"></span><br><span class="line">	left = i</span><br><span class="line">	<span class="keyword">for</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; j-- &#123;</span><br><span class="line">		<span class="keyword">if</span> height[j] &gt; heights[i] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		left = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	right = i</span><br><span class="line">	<span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt;= <span class="built_in">len</span>(heights) ; j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> height[j] &lt; heights[i] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		right = j</span><br><span class="line">	&#125;</span><br><span class="line">	area = (right - left + <span class="number">1</span>) * height[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-分治法"><a href="#2-2-2-分治法" class="headerlink" title="2.2.2 分治法"></a>2.2.2 分治法</h4><p>分界点： 面积的大小是由所有柱子中最矮的决定的，所以我们以最矮的柱子为分界点</p>
<p>最大面积的分布又3种情况 1） 在左侧 2）在中间，通过中间联通两侧 3）在右侧</p>
<p>可以用分治的算法进行计算， 时间复杂度:<br>$$T(n) &#x3D; 2(\frac {n} {2}) + O(logn) &#x3D; O(nlogn)$$</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">device(heigths []<span class="type">int</span>, left,right <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	middle = findMin(heigths,left,right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max((right-left + <span class="number">1</span>) * heigths[middle], device(heigths,left,middle - <span class="number">1</span>), device(middle+<span class="number">1</span>,right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> device(heigths,<span class="number">0</span>,<span class="built_in">len</span>(heigths)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2019/03/05/go-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/05/go-pointer/" class="post-title-link" itemprop="url">go 指针学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-05 17:36:27" itemprop="dateCreated datePublished" datetime="2019-03-05T17:36:27+00:00">2019-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> 指针就是一个变量，用于存储另一个变量的内存地址，所有的数据都存储在内存中，<strong>变量</strong> 只是给某一块的地址起的别名。</p>
<p>指针也是一个变量，他指向的内存存储的不仅是一个值，而且是另一个值的内存地址</p>
<p><img src="https://github.com/lys091112/lys091112.github.io/blob/hexo/hexo/source/images/pointer.jpeg?raw=true" alt="指针图示"></p>
<h3 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h3><p>指针的的语法声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 通过符号*可以声明指针类型，t只保留类型为T的类型指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何未初始化的指针值都为nil</span></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指针的初始化-和-输出"><a href="#指针的初始化-和-输出" class="headerlink" title="指针的初始化 和 输出"></a>指针的初始化 和 输出</h3><p>指针的初始化只需给它赋予其他变量的内存地址入口，变量的地址通过符号&amp;获取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Println(a) <span class="comment">//10</span></span><br><span class="line">fmt.Println(p) <span class="comment">// a 的内存地址</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 10 通过*号，可以解引用，输出内存地址存储的变量值</span></span><br></pre></td></tr></table></figure>

<h3 id="多重指针"><a href="#多重指针" class="headerlink" title="多重指针"></a>多重指针</h3><p>确切含义是指向指针的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &amp;a</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pp = &amp;p</span><br><span class="line"></span><br><span class="line">fmt.Println(a) <span class="comment">//10</span></span><br><span class="line">fmt.Println(p) <span class="comment">// a 的内存地址</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 10 输出a的值</span></span><br><span class="line">fmt.Println(&amp;p) <span class="comment">// 输出p的内存地址</span></span><br><span class="line">fmt.Println(pp) <span class="comment">// 输出p的内存地址</span></span><br><span class="line">fmt.Println(*pp) <span class="comment">//输出a的内存地址 </span></span><br><span class="line">fmt.Println(***pp) <span class="comment">// 10 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="通过引用赋值"><a href="#通过引用赋值" class="headerlink" title="通过引用赋值"></a>通过引用赋值</h3><p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指针的使用</span></span><br><span class="line">    <span class="keyword">var</span> k <span class="type">int</span></span><br><span class="line">    setK(&amp;k)</span><br><span class="line">    fmt.Print(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setK</span><span class="params">(key *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  *key = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>tip: </font> go中没有指针算术运算</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2019/02/24/go-module-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/24/go-module-md/" class="post-title-link" itemprop="url">go module 初步认知</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-24 18:02:04" itemprop="dateCreated datePublished" datetime="2019-02-24T18:02:04+00:00">2019-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>在 go1.11 之前，不是使用gdep, glide，就是直接使用go get安装第三方包<br>工作空间Workspaces，是Go项目的根目录，也就是<code>GOPATH</code> 是GO项目必备的环境变量，用来存放Go的开发代码和第三方包代码，代码需要按照一定的目录安排</p>
<h2 id="mod-特性"><a href="#mod-特性" class="headerlink" title="mod 特性"></a>mod 特性</h2><h3 id="模块定义："><a href="#模块定义：" class="headerlink" title="模块定义："></a>模块定义：</h3><p>模块根目录和其子目录的所有包构成模块，在根目录下存在 go.mod 文件，子目录会向着父目录、爷目录一直找到 go.mod 文件</p>
<p>环境变量 GO111MODULE 开启或关闭模块支持</p>
<ul>
<li>GO111MODULE&#x3D;off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li>
<li>GO111MODULE&#x3D;on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li>
<li>GO111MODULE&#x3D;auto 在 <code>$GOPATH/src</code> 外面且根目录有 go.mod 文件时，开启模块支持</li>
</ul>
<p>go.mod 可以用来定义当前模块依赖和版本，也可以用来替换和排除依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义的模块名称</span><br><span class="line">module example.com/m</span><br><span class="line"></span><br><span class="line">// 模块依赖</span><br><span class="line">require (</span><br><span class="line">    golang.org/x/text v0.3.0</span><br><span class="line">    gopkg.in/yaml.v2 v2.1.0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 有时由于网络原因，golang.org/x下的包加载不到，可以使用github.com下的包替代</span><br><span class="line">replace (</span><br><span class="line">    golang.org/x/text =&gt; github.com/golang/text v0.3.0</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>require语句指定的依赖项模块</li>
<li>replace语句可以替换依赖项模块</li>
<li>exclude语句可以忽略依赖项模块</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>go mod init:初始化modules</li>
<li>go mod download:下载modules到本地cache</li>
<li>go mod edit:编辑go.mod文件，选项有-json、-require和-exclude，可以使用帮助go help mod edit</li>
<li>go mod graph:以文本模式打印模块需求图</li>
<li>go mod tidy:删除错误或者不使用的modules</li>
<li>go mod vendor:生成vendor目录</li>
<li>go mod verify:验证依赖是否正确</li>
<li>go mod why：查找依赖</li>
</ul>
<p>go build -getmode&#x3D;vendor 在开启模块支持的情况下，用这个可以退回到使用 vendor 的时代</p>
<h3 id="go的-mod与get"><a href="#go的-mod与get" class="headerlink" title="go的 mod与get"></a>go的 mod与get</h3><pre><code>go get 命令会将文件下载到$GOPATH/src 下的相应目录
go mod 会把文件下载到$GOPATH/pkg/mode 目录下，供其他项目共享
</code></pre>
<p>go get命令也与时俱进，支持了modules</p>
<ul>
<li>运行 go get -u 将会升级到最新的次要版本或者修订版本</li>
<li>运行 go get -u&#x3D;patch 将会升级到最新的修订版本（比如说，将会升级到 1.0.1 版本，但不会升级到 1.1.0 版本）</li>
<li>运行 go get package@version将会升级到指定的版本号</li>
</ul>
<h2 id="如何创建go-module项目"><a href="#如何创建go-module项目" class="headerlink" title="如何创建go module项目"></a>如何创建go module项目</h2><ol>
<li>定义入口文件</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package main 后一定要跟import 注释的内容就是模块的名称</span></span><br><span class="line"><span class="keyword">package</span> main <span class="comment">// import &quot;github.com//xxx/examples/modules&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在项目目录下执行初始化操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init</span><br><span class="line">go: creating new go.mod: module github.com/xxx/examples/modules</span><br></pre></td></tr></table></figure>
<pre><code>TIP: 不能在GOPATH 所在的目录下创建mod，不然会报异常
</code></pre>
<ol start="3">
<li>编译执行,查看是否正常</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build .</span><br><span class="line">$ ./modules </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考文档: <a target="_blank" rel="noopener" href="https://www.mycodesmells.com/post/go-modules-example">Go modules example</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2018/05/02/shell_first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/02/shell_first/" class="post-title-link" itemprop="url">一个小脚本引发的点滴记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-02 16:02:25" itemprop="dateCreated datePublished" datetime="2018-05-02T16:02:25+00:00">2018-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="zsh自定义脚本"><a href="#zsh自定义脚本" class="headerlink" title="zsh自定义脚本"></a>zsh自定义脚本</h2><p>在 zsh脚本中添加自定义的快捷方式, 脚本内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dkexec &#123;</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Usage: dockerexec mysql|redis|...&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        image=`docker ps | grep <span class="variable">$1</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$image</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;can&#x27;t find image by name <span class="variable">$1</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            docker <span class="built_in">exec</span> -it <span class="variable">$&#123;image&#125;</span> bash</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遇到的问题：</strong></p>
<ol>
<li><p>判断语句与括号间需要空格分割</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -z &quot;$1&quot;] 如果$1所在的位置与]之间没有空格，那么会报错误 “dkexec:[:1: &#x27;]&#x27; expected” </span><br><span class="line"></span><br><span class="line">如果 $1为空，那么就变成了 if[ -z ], 会把]当成一个字符，引发异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的if都需要相应的fi来进行闭合</p>
</li>
<li><p>在使用awk的print方法时，如果保证获取的结果值可以赋值给结果变量？</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要将语句用反引号``包括起来，才能将结果值赋予image</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="引申的知识点"><a href="#引申的知识点" class="headerlink" title="引申的知识点"></a>引申的知识点</h2><h3 id="0-1-2-变量的含义"><a href="#0-1-2-变量的含义" class="headerlink" title="** $0, $1, $2 ...变量的含义**"></a>** <code>$0, $1, $2 ...</code>变量的含义**</h3><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<code>$1</code>，第二个参数是<code>$2</code>。</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 <code>$*</code> 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody></table>
<pre><code>`$*` 和 `$@` 的区别

    `$*` 和 `$@` 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以&quot;`$1`&quot; &quot;`$2`&quot; … &quot;`$n`&quot; 的形式输出所有参数

    但是当它们被双引号(&quot; &quot;)包含时，&quot;`$*`&quot; 会将所有的参数作为一个整体，以&quot;`$1` `$2` … `$n`&quot;的形式输出所有参数；&quot;`$@`&quot; 会将各个参数分开，以&quot;`$1`&quot; &quot;`$2`&quot; … &quot;`$n`&quot; 的形式输出所有参数。
</code></pre>
<h3 id="z-a-等判断条件的使用"><a href="#z-a-等判断条件的使用" class="headerlink" title="-z -a ... 等判断条件的使用"></a><strong><code>-z -a ... </code>等判断条件的使用</strong></h3><pre><code>- 字符串判断
    str1 = str2　　　　　　当两个串有相同内容、长度时为真
    str1 != str2　　　　　 当串str1和str2不等时为真
    -n str1　　　　　　　 当串的长度大于0时为真(串非空)
    -z str1　　　　　　　 当串的长度为0时为真(空串)
    str1　　　　　　　　   当串str1为非空时为真

- 数字的判断
    int1 -eq int2　　　　两数相等为真
    int1 -ne int2　　　　两数不等为真
    int1 -gt int2　　　　int1大于int2为真
    int1 -ge int2　　　　int1大于等于int2为真
    int1 -lt int2　　　　int1小于int2为真
    int1 -le int2　　　　int1小于等于int2为真

- 文件的判断
    -r file　　　　　用户可读为真
    -w file　　　　　用户可写为真
    -x file　　　　　用户可执行为真
    -f file　　　　　文件为正规文件为真
    -d file　　　　　文件为目录为真
    -c file　　　　　文件为字符特殊文件为真
    -b file　　　　　文件为块特殊文件为真
    -s file　　　　　文件大小非0时为真
    -t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真

- 复杂逻辑判断
    -a 　 　　　　　 与
    -o　　　　　　　 或
    !　　　　　　　　非
</code></pre>
<p>附表：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ -a FILE ]</td>
<td>如果 FILE 存在则为真。</td>
</tr>
<tr>
<td>[ -b FILE ]</td>
<td>如果 FILE 存在且是一个块特殊文件则为真。</td>
</tr>
<tr>
<td>[ -c FILE ]</td>
<td>如果 FILE 存在且是一个字特殊文件则为真。</td>
</tr>
<tr>
<td>[ -d FILE ]</td>
<td>如果 FILE 存在且是一个目录则为真。</td>
</tr>
<tr>
<td>[ -e FILE ]</td>
<td>如果 FILE 存在则为真。</td>
</tr>
<tr>
<td>[ -f FILE ]</td>
<td>如果 FILE 存在且是一个普通文件则为真。</td>
</tr>
<tr>
<td>[ -g FILE ]</td>
<td>如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ]  如果 FILE 存在且是一个符号连接则为真。</td>
</tr>
<tr>
<td>[ -k FILE ]</td>
<td>如果 FILE 存在且已经设置了粘制位则为真。</td>
</tr>
<tr>
<td>[ -p FILE ]</td>
<td>如果 FILE 存在且是一个名字管道(F如果O)则为真。</td>
</tr>
<tr>
<td>[ -r FILE ]</td>
<td>如果 FILE 存在且是可读的则为真。</td>
</tr>
<tr>
<td>[ -s FILE ]</td>
<td>如果 FILE 存在且大小不为0则为真。</td>
</tr>
<tr>
<td>[ -t FD ]</td>
<td>如果文件描述符 FD 打开且指向一个终端则为真。</td>
</tr>
<tr>
<td>[ -u FILE ]</td>
<td>如果 FILE 存在且设置了SUID (set user ID)则为真。</td>
</tr>
<tr>
<td>[ -w FILE ]</td>
<td>如果 FILE 如果 FILE 存在且是可写的则为真。</td>
</tr>
<tr>
<td>[ -x FILE ]</td>
<td>如果 FILE 存在且是可执行的则为真。</td>
</tr>
<tr>
<td>[ -O FILE ]</td>
<td>如果 FILE 存在且属有效用户ID则为真。</td>
</tr>
<tr>
<td>[ -G FILE ]</td>
<td>如果 FILE 存在且属有效用户组则为真。</td>
</tr>
<tr>
<td>[ -L FILE ]</td>
<td>如果 FILE 存在且是一个符号连接则为真。</td>
</tr>
<tr>
<td>[ -N FILE ]</td>
<td>如果 FILE 存在 and has been mod如果ied since it was last read则为真。</td>
</tr>
<tr>
<td>[ -S FILE ]</td>
<td>如果 FILE 存在且是一个套接字则为真。</td>
</tr>
<tr>
<td>[ FILE1 -nt FILE2 ]</td>
<td>如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。</td>
</tr>
<tr>
<td>[ FILE1 -ot FILE2 ]</td>
<td>如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。</td>
</tr>
<tr>
<td>[ FILE1 -ef FILE2 ]</td>
<td>如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</td>
</tr>
<tr>
<td>[ -o OPTIONNAME ]</td>
<td>如果 shell选项 “OPTIONNAME” 开启则为真。</td>
</tr>
<tr>
<td>[ -z STRING ]</td>
<td>“STRING” 的长度为零则为真。</td>
</tr>
<tr>
<td>[ -n STRING ] or [ STRING ]</td>
<td>“STRING” 的长度为非零 non-zero则为真。</td>
</tr>
<tr>
<td>[ STRING1 &#x3D;&#x3D; STRING2 ]</td>
<td>如果2个字符串相同。 “&#x3D;” may be used instead of “&#x3D;&#x3D;” for strict POSIX compliance则为真。</td>
</tr>
<tr>
<td>[ STRING1 !&#x3D; STRING2 ]</td>
<td>如果字符串不相等则为真。</td>
</tr>
<tr>
<td>[ STRING1 <code>&lt;</code> STRING2 ]</td>
<td>如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。</td>
</tr>
<tr>
<td>[ STRING1 &gt; STRING2 ]</td>
<td>如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。</td>
</tr>
<tr>
<td>[ ARG1 OP ARG2 ]</td>
<td>“OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lys091112.github.io/2018/04/17/aqs-exclusive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Crescent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Crescent">
      <meta itemprop="description" content="且行且珍惜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Crescent">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/17/aqs-exclusive/" class="post-title-link" itemprop="url">java同步器AQS的独享模式分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-17 07:29:25" itemprop="dateCreated datePublished" datetime="2018-04-17T07:29:25+00:00">2018-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-12 22:18:25" itemprop="dateModified" datetime="2024-03-12T22:18:25+00:00">2024-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在java.util.concurrent包中有很多控制同步和并发的类，其中向ReentrantLock，CountDownLatch 内部实现都依赖与AbstractQueuedSynchronizer（用于控制同步的框架AQS），下面我们来分析独占模式下的原理</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>队列同步器AQS是用来构建锁和其他同步组件的基础框架，内部使用int来表示成员的同步状态，通过内置的FIFO队列来完成资源获取线程的排序工作，其中成员变量包括 内部状态state 、等待队列的对头head(对头是一个空节点,也可以认为是当前持有锁的线程)、等待队列的队尾tail，都是通过volatile修饰，保证在并发过程中对其他线程可见</p>
<p>基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS内部队列的实现原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>每当有线程竞争锁失败，那么会将其加入到队列的队尾，tail始终指向最后一个元素</p>
</li>
<li><p>节点存储的信息包括 节点的模式，前驱和后继节点，当前线程引用，以及当前状态waitStatus,<br>多线程并发时，会存在多个线程节点，waitStatus表示当前节点的状态，有的线程可能在等待过程中放弃，有的节点可能在等待条件满足后在触发。状态分为以下四种：</p>
<ul>
<li>CANCELLED 取消状态</li>
<li>SIGNAL 等待触发状态</li>
<li>CONDITION 等待条件状态</li>
<li>PROPAGATE 状态需要向后传播</li>
</ul>
</li>
<li><p>等待队列是FIFO先进先出，只有前一个节点的状态为SIGNAL时，当前节点的线程才能被挂起。</p>
</li>
</ul>
<h2 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h2><ol>
<li>acquire(int)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/** 需要有子类进行实现 **/</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<pre><code>1. tryAcquire 尝试获取锁资源，如果获取成功，直接返回
2. 首先通过addWaiter 以独占模式将当前线程添加到队尾，而后accquireQueued 在队列中获取资源，直到获取到资源,如果在获取过程中被中断，则返回true，否则返回false
3. 线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上
</code></pre>
<ol start="2">
<li>addWaiter(Node)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>1. 首先尝试将节点直接加入队列，如果在加入过程中队尾不为空，其没有变化，那么直接加入并返回
2. 如果队尾为空，或者在加入过程中队尾指针变化，那么需要重新检测并入队。通过一个自循环，不停的检测，直到加入成功。首先获取队列队尾，检查队尾是否为空，如果为空则代表没有其他等待节点，那么首先初始化队列，将对象头置为不包含任何数据的节点，并同步队尾指针然后再次循环检查
3. 如果队尾节点不为空，那么尝试将节点添加到队尾
</code></pre>
<ol start="3">
<li>acquireQueued(node, int)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。
1. 检查当前节点的前驱节点，如果前驱节点是头节点，那么更新头节点，并返回是否在获取过程中被中断(在addWaiter中如果队列为空那么会先初始化一个头节点，然后将节点添加进去，在这一步又使用节点替换头节点)
2. 如果前驱非头节点，那么检查是否需要检查等待状态然后等待被唤醒并检查是否在等待过程中被中断
</code></pre>
<ol start="4">
<li>shouldParkAfterFailedAcquire(node,node)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>1. 检查上一个节点的状态是否是可唤醒状态，如果是则返回true，并执行parkAndCheckInterrupt进行park
2. 如果不是，那么针对于状态大于0的都是取消状态，需要忽略，那么从队尾指针往前找直到某个状态小于等于0，那节点的前驱节点设置为找寻到的节点，然后进行新一轮的自旋迭代

3. 如果不是可唤醒状态，而且状态不大于0，那么需要修改节点状态，再一次自旋
</code></pre>
<p>结合aquireQueued，流程如下：<br>    1. 结点进入队尾后，检查状态，找到安全休息点；<br>    2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；<br>    3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</p>
<ol start="5">
<li>release(int)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 由子类实现 **/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>1. 根据tryRelease 查看是否释放成功
2. 如果释放成功，那么对线程进行unpark唤起 head节点一般是当前线程所在节点，首先查看head节点的状态，如果状态小于0，那么将其置为0，然后遍历查找下一个需要唤醒的节点，如果节点的状态大于0，表明该节点已经取消，那么需要从队尾遍历往前找到最头不为且状态不大于0的节点进行唤醒
</code></pre>
<p>总结：</p>
<p>以上就是AQS对于独占模式下线程竞争的数据处理过程,下节分析共享模式下的处理流程</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Crescent</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
